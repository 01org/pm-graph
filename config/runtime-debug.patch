diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index ef13ad08..daaaef20 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -11,6 +11,7 @@
 #include <linux/export.h>
 #include <linux/pm_runtime.h>
 #include <trace/events/rpm.h>
+#include <linux/suspend.h>
 #include "power.h"
 
 static int rpm_resume(struct device *dev, int rpmflags);
@@ -336,6 +337,35 @@ static int rpm_idle(struct device *dev, int rpmflags)
 	return retval;
 }
 
+static ktime_t rpm_callback_debug_start(struct device *dev, const char *name)
+{
+	ktime_t calltime = ktime_set(0, 0);
+
+	if (pm_print_times_enabled) {
+		pr_info("calling  %s+ @ %i, parent: %s, %s\n",
+			dev_name(dev), task_pid_nr(current),
+			dev->parent ? dev_name(dev->parent) : "none",
+			name);
+		calltime = ktime_get();
+	}
+
+	return calltime;
+}
+
+static void rpm_callback_debug_report(struct device *dev, ktime_t calltime,
+				  int error, const char *name)
+{
+	ktime_t delta, rettime;
+
+	if (pm_print_times_enabled) {
+		rettime = ktime_get();
+		delta = ktime_sub(rettime, calltime);
+		pr_info("call %s+ returned %d after %Ld usecs, %s\n", dev_name(dev),
+			error, (unsigned long long)ktime_to_ns(delta) >> 10,
+			name);
+	}
+}
+
 /**
  * rpm_callback - Run a given runtime PM callback for a given device.
  * @cb: Runtime PM callback to run.
@@ -587,6 +617,7 @@ static int rpm_suspend(struct device *dev, int rpmflags)
 static int rpm_resume(struct device *dev, int rpmflags)
 	__releases(&dev->power.lock) __acquires(&dev->power.lock)
 {
+	ktime_t calltime;
 	int (*callback)(struct device *);
 	struct device *parent = NULL;
 	int retval = 0;
@@ -739,7 +770,10 @@ static int rpm_resume(struct device *dev, int rpmflags)
 	if (!callback && dev->driver && dev->driver->pm)
 		callback = dev->driver->pm->runtime_resume;
 
+	calltime = rpm_callback_debug_start(dev, "rpm_resume");
 	retval = rpm_callback(callback, dev);
+	rpm_callback_debug_report(dev, calltime, retval, "rpm_resume");
+
 	if (retval) {
 		__update_runtime_status(dev, RPM_SUSPENDED);
 		pm_runtime_cancel_pending(dev);
