-- Overview --

AnalyzeSuspend: suspend/resume timing analysis tool
       Version: 4.3
        Author: Todd Brandt <todd.e.brandt@linux.intel.com>
     Home Page: https://01.org/suspendresume

Full documentation available online
	- Getting Started:
	  https://01.org/suspendresume/documentation/getting-started

	- Option List:
	  https://01.org/suspendresume/documentation/2-command-list

	- Config File Format:
	  https://01.org/suspendresume/documentation/3-config-file-format

	- v4.3 git release:
	  https://github.com/01org/suspendresume/releases/tag/4.3

	- upstream version in git:
	  https://github.com/01org/suspendresume/


-- Description --

This tool is designed to assist kernel and OS developers in optimizing
their linux stack's suspend/resume time. Using a kernel image built 
with a few extra options enabled and a small patch to enable ftrace, 
the tool will execute a suspend, and will capture dmesg and ftrace
data until resume is complete. This data is transformed into a set of 
timelines and a callgraph to give a quick and detailed view of which
devices and kernel processes are taking the most time in suspend/resume.


-- Setup (Kernel Configuration) --

    The following kernel build options are required for all kernels:
        CONFIG_PM_DEBUG=y
        CONFIG_PM_SLEEP_DEBUG=y
        CONFIG_FTRACE=y
        CONFIG_FUNCTION_TRACER=y
        CONFIG_FUNCTION_GRAPH_TRACER=y
        CONFIG_KPROBES=y
        CONFIG_KPROBES_ON_FTRACE=y

        There is a patch which does this for the ubuntu raring kernel:
        (config/analyze_suspend_kconfig_ubuntu.patch)

	In kernel 3.15.0, two patches were upstreamed which enable the
        v3.0 behavior. These patches allow the tool to read all the
        data from trace events instead of from dmesg. You can enable
        this behavior on earlier kernels with these patches:

        (config/pre-3.15/enable_trace_events_suspend_resume.patch)
        (config/pre-3.15/enable_trace_events_device_pm_callback.patch)

	If you're using a kernel older than 3.15.0, the following
        additional kernel parameters are required:
        (e.g. in file /etc/default/grub)
        GRUB_CMDLINE_LINUX_DEFAULT="... initcall_debug log_buf_len=32M ..."

	If you're using a kernel older than 3.11-rc2, the following simple
		patch must be applied to enable ftrace data:
        in file: kernel/power/suspend.c
        in function: int suspend_devices_and_enter(suspend_state_t state)
        remove call to "ftrace_stop();"
        remove call to "ftrace_start();"

        There is a patch which does this for kernel v3.8.0:
        (config/pre-3.11-rc2/enable_ftrace_in_suspendresume.patch)


-- Basic Usage --

 1) First configure a kernel using the instructions from the previous sections.
    Then build, install, and boot with it. 
 2) Open up a terminal window and execute the mode list command:

	%> sudo ./analyze_suspend.py -modes
		['freeze', 'mem', 'disk']

 Execute a test using one of the available power modes, e.g. mem (S3):

	%> sudo ./analyze-suspend.py -m mem -rtcwake 15

		or with a config file

	%> sudo ./analyze-suspend.py -config config/suspend.cfg

 When the system comes back you'll see the script finishing up and 
 creating the output files in the test subdir. It generates output 
 files in subdirectory: suspend-mmddyy-HHMMSS. The ftrace file can 
 be used to regenerate the html timeline with different options

     HTML output:                    <hostname>_<mode>.html
     raw dmesg output:               <hostname>_<mode>_dmesg.txt
     raw ftrace output:              <hostname>_<mode>_ftrace.txt

 View the html in firefox or chrome.


-- Dev Mode Usage --

 Developer mode adds information on low level source calls to the timeline.
 The tool sets kprobes on all delay and mutex calls to see which devices
 are waiting for something and when. It also sets a suite of kprobes on
 subsystem dependant calls to better fill out the timeline.

 The tool will also expose kernel threads that don't normally show up in the
 timeline. This is useful in discovering dependant threads to get a better
 idea of what each device is waiting for. For instance, the scsi_eh thread,
 a.k.a. scsi resume error handler, is what each SATA disk device waits for
 before it can continue resume. 

 The timeline will be much larger if run with dev mode, so it can be useful
 to set the -mindev option to clip out any device blocks that are too small
 to see easily. The following command will give a nice dev mode run:

 %> sudo ./analyze_suspend.py -m mem -rtcwake 15 -mindev 1 -dev

	or with a config file

 %> sudo ./analyze-suspend.py -config config/suspend-dev.cfg


-- Proc Mode Usage --

 Proc mode adds user process info to the timeline. This is done in a manner
 similar to the bootchart utility, which graphs init processes and their
 execution as the system boots. This tool option does the same thing but for
 the period before and after suspend/resume.

 In order to see any process info, there needs to be some delay before or
 after resume since processes are frozen in suspend_prepare and thawed in
 resume_complete. The predelay and postdelay args allow you to do this. It
 can also be useful to run in x2 mode with an x2 delay, this way you can
 see process activity before and after resume, and in between two
 successive suspend/resumes.

 The command can be run like this:

 %> sudo ./analyze_suspend.py -m mem -rtcwake 15 -x2 -x2delay 1000 -predelay 1000 -postdelay 1000 -proc

	or with a config file

 %> sudo ./analyze_suspend.py -config config/suspend-proc.cfg


-- Using config files --

 In 4.0 we've moved to using config files in lieu of command line options. The
 config folder contains a collection of typical use cases.

 Run a standard suspend:
 %> sudo ./analyze_suspend.py -config config/suspend.cfg

 Run a standard suspend with callgraph data:
 %> sudo ./analyze_suspend.py -config config/suspend-callgraph.cfg

 Run a standard suspend with dev mode detail:
 %> sudo ./analyze_suspend.py -config config/suspend-dev.cfg

 There are corresponding configs for other power modes:

	freeze-callgraph.cfg
	freeze.cfg
	freeze-dev.cfg
	standby-callgraph.cfg
	standby.cfg
	standby-dev.cfg




-- Android Usage --

The easiest way to execute on an android device is to run the android.sh
script on the device, then pull the ftrace log back to the host and run
analyze_suspend.py on it.

Here are the steps:

[download and install the tool on the device]
host%> wget https://raw.githubusercontent.com/01org/suspendresume/master/android.sh
host%> adb connect 192.168.1.6
host%> adb root
# push the script to a writeable location
host%> adb push android.sh /sdcard/

[check whether the tool will run on your device]
host%> adb shell
dev%> cd /sdcard
dev%> sh android.sh status
	host    : asus_t100
	kernel  : 3.14.0-i386-dirty
	modes   : freeze mem
	rtcwake : supported
	ftrace  : supported
	trace events {
	    suspend_resume: found
	    device_pm_callback_end: found
	    device_pm_callback_start: found
	}
# the above is what you see on a system that's properly patched

[execute the suspend]
# NOTE: The suspend will only work if the screen isn't timed out,
# so you have to press some keys first to wake it up b4 suspend)
dev%> sh android.sh suspend mem
------------------------------------
Suspend/Resume timing test initiated
------------------------------------
hostname   : asus_t100
kernel     : 3.14.0-i386-dirty
mode       : mem
ftrace out : /mnt/shell/emulated/0/ftrace.txt
dmesg out  : /mnt/shell/emulated/0/dmesg.txt
log file   : /mnt/shell/emulated/0/log.txt
------------------------------------
INITIALIZING FTRACE........DONE
STARTING FTRACE
SUSPEND START @ 21:24:02 (rtcwake in 10 seconds)
<adb connection will now terminate>

[retrieve the data from the device]
# I find that you have to actually kill the adb process and 
# reconnect sometimes in order for the connection to work post-suspend
host%> adb connect 192.168.1.6
# (required) get the ftrace data, this is the most important piece
host%> adb pull /sdcard/ftrace.txt
# (optional) get the dmesg data, this is for debugging
host%> adb pull /sdcard/dmesg.txt
# (optional) get the log, which just lists some test times for comparison
host%> adb pull /sdcard/log.txt

[create an output html file using analyze_suspend.py]
host%> analyze_suspend.py -ftrace ftrace.txt

You should now have an output.html with the android data, enjoy!
