From 113dae831d078192b3f7fb36305cab7b83f881c3 Mon Sep 17 00:00:00 2001
Message-Id: <113dae831d078192b3f7fb36305cab7b83f881c3.1480733080.git.todd.e.brandt@linux.intel.com>
In-Reply-To: <cover.1480733080.git.todd.e.brandt@linux.intel.com>
References: <cover.1480733080.git.todd.e.brandt@linux.intel.com>
From: Todd Brandt <todd.e.brandt@linux.intel.com>
Date: Fri, 2 Dec 2016 18:44:09 -0800
Subject: [PATCH 2/2] usb: resume delay debug

add debug support for experimenting with USB timing delay
values on the fly.

Signed-off-by: Todd Brandt <todd.e.brandt@linux.intel.com>
---
 drivers/usb/core/hub.c | 100 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 100 insertions(+)

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 28d91aa..d66f837 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -5265,6 +5265,93 @@ static struct usb_driver hub_driver = {
 	.supports_autosuspend =	1,
 };
 
+static ssize_t tdrsmdn_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", usb_timing.tdrsmdn);
+}
+
+static ssize_t tdrsmdn_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int ret, val;
+
+	ret = kstrtoint(buf, 10, &val);
+	if (ret < 0)
+		return ret;
+
+	if (val < 20)
+		usb_timing.tdrsmdn = 20;
+	else
+		usb_timing.tdrsmdn = val;
+
+	return count;
+}
+
+static ssize_t trsmrcy_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", usb_timing.trsmrcy);
+}
+
+static ssize_t trsmrcy_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int ret, val;
+
+	ret = kstrtoint(buf, 10, &val);
+	if (ret < 0)
+		return ret;
+
+	if (val < 10)
+		usb_timing.trsmrcy = 10;
+	else
+		usb_timing.trsmrcy = val;
+
+	return count;
+}
+
+static ssize_t trstrcy_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", usb_timing.trstrcy);
+}
+
+static ssize_t trstrcy_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int ret, val;
+
+	ret = kstrtoint(buf, 10, &val);
+	if (ret < 0)
+		return ret;
+
+	if (val < 0)
+		usb_timing.trstrcy = 0;
+	else
+		usb_timing.trstrcy = val;
+
+	return count;
+}
+
+static struct kobj_attribute tdrsmdn_attr =
+	__ATTR(tdrsmdn, 0664, tdrsmdn_show, tdrsmdn_store);
+static struct kobj_attribute trsmrcy_attr =
+	__ATTR(trsmrcy, 0664, trsmrcy_show, trsmrcy_store);
+static struct kobj_attribute trstrcy_attr =
+	__ATTR(trstrcy, 0664, trstrcy_show, trstrcy_store);
+
+static struct attribute *attrs[] = {
+	&tdrsmdn_attr.attr,
+	&trsmrcy_attr.attr,
+	&trstrcy_attr.attr,
+	NULL
+};
+
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
 static void usb_timing_config_set(const char *name)
 {
 	if (!strcmp(name, "default")) {
@@ -5282,6 +5369,9 @@ static void usb_timing_config_set(const char *name)
 
 int usb_hub_init(void)
 {
+	int retval;
+	struct kobject *usb_kobj;
+
 	if (usb_register(&hub_driver) < 0) {
 		printk(KERN_ERR "%s: can't register hub driver\n",
 			usbcore_name);
@@ -5290,6 +5380,16 @@ int usb_hub_init(void)
 
 	usb_timing_config_set(timing_config);
 
+	usb_kobj = kobject_create_and_add("usb", kernel_kobj);
+	if (!usb_kobj)
+		return -ENOMEM;
+
+	retval = sysfs_create_group(usb_kobj, &attr_group);
+	if (retval) {
+		kobject_put(usb_kobj);
+		return retval;
+	}
+
 	/*
 	 * The workqueue needs to be freezable to avoid interfering with
 	 * USB-PERSIST port handover. Otherwise it might see that a full-speed
-- 
2.1.4

